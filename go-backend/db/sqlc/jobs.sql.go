// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: jobs.sql

package db

import (
	"context"
	"time"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    description, client_name, client_address, client_email, price, start_date, end_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, description, client_name, client_address, client_email, price, start_date, end_date, created_at
`

type CreateJobParams struct {
	Description   string    `json:"description"`
	ClientName    string    `json:"client_name"`
	ClientAddress string    `json:"client_address"`
	ClientEmail   string    `json:"client_email"`
	Price         int64     `json:"price"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Description,
		arg.ClientName,
		arg.ClientAddress,
		arg.ClientEmail,
		arg.Price,
		arg.StartDate,
		arg.EndDate,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ClientName,
		&i.ClientAddress,
		&i.ClientEmail,
		&i.Price,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const getJob = `-- name: GetJob :one
SELECT id, description, client_name, client_address, client_email, price, start_date, end_date, created_at FROM jobs
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ClientName,
		&i.ClientAddress,
		&i.ClientEmail,
		&i.Price,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT id, description, client_name, client_address, client_email, price, start_date, end_date, created_at FROM jobs
ORDER BY created_at DESC
`

func (q *Queries) ListJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.ClientName,
			&i.ClientAddress,
			&i.ClientEmail,
			&i.Price,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs
    set description = $1,
    client_name = $2,
    client_address = $3,
    client_email = $4,
    price = $5,
    start_date = $6,
    end_date = $7
WHERE id = $8
RETURNING id, description, client_name, client_address, client_email, price, start_date, end_date, created_at
`

type UpdateJobParams struct {
	Description   string    `json:"description"`
	ClientName    string    `json:"client_name"`
	ClientAddress string    `json:"client_address"`
	ClientEmail   string    `json:"client_email"`
	Price         int64     `json:"price"`
	StartDate     time.Time `json:"start_date"`
	EndDate       time.Time `json:"end_date"`
	ID            int64     `json:"id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.Description,
		arg.ClientName,
		arg.ClientAddress,
		arg.ClientEmail,
		arg.Price,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.ClientName,
		&i.ClientAddress,
		&i.ClientEmail,
		&i.Price,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}
